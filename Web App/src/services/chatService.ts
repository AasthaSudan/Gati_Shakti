// services/chatService.ts
import { 
  ref, 
  push, 
  onValue, 
  off, 
  set, 
  update,
  orderByChild,
  query,
  limitToLast
} from 'firebase/database';
import { database } from '@/lib/firebase';
import { ChatMessage, ChatRoom, User } from '@/types';

export class ChatService {
  private static instance: ChatService;

  public static getInstance(): ChatService {
    if (!ChatService.instance) {
      ChatService.instance = new ChatService();
    }
    return ChatService.instance;
  }

  // Send a message
  async sendMessage(roomId: string, message: Omit<ChatMessage, 'id' | 'timestamp'>): Promise<void> {
    try {
      const messagesRef = ref(database, `chats/${roomId}/messages`);
      const newMessage: ChatMessage = {
        ...message,
        id: '', // Will be generated by Firebase
        timestamp: Date.now(),
      };
      
      await push(messagesRef, newMessage);
      
      // Update room's last message and timestamp
      const roomRef = ref(database, `chats/${roomId}`);
      await update(roomRef, {
        lastMessage: newMessage,
        updatedAt: Date.now(),
        [`unreadCount/${message.senderRole === 'train_driver' ? 'stationAdmin' : 'trainDriver'}`]: 
          (await this.getUnreadCount(roomId, message.senderRole === 'train_driver' ? 'station_admin' : 'train_driver')) + 1
      });
    } catch (error) {
      console.error('Error sending message:', error);
      throw error;
    }
  }

  // Listen to messages in a chat room
  subscribeToMessages(roomId: string, callback: (messages: ChatMessage[]) => void): () => void {
    const messagesRef = ref(database, `chats/${roomId}/messages`);
    const messagesQuery = query(messagesRef, orderByChild('timestamp'), limitToLast(50));

    const unsubscribe = onValue(messagesQuery, (snapshot) => {
      const messages: ChatMessage[] = [];
      if (snapshot.exists()) {
        snapshot.forEach((childSnapshot) => {
          const message = childSnapshot.val() as ChatMessage;
          message.id = childSnapshot.key!;
          messages.push(message);
        });
      }
      callback(messages);
    });

    return () => off(messagesRef, 'value', unsubscribe);
  }

  // Create or get chat room
  async createOrGetChatRoom(trainNumber: string, stationCode: string, trainDriver: User, stationAdmin: User): Promise<string> {
    const roomId = `${trainNumber}_${stationCode}`;
    const roomRef = ref(database, `chats/${roomId}`);

    const room: ChatRoom = {
      id: roomId,
      trainNumber,
      stationCode,
      participants: {
        trainDriver: {
          id: trainDriver.id,
          name: trainDriver.name,
          trainNumber: trainDriver.trainNumber!,
        },
        stationAdmin: {
          id: stationAdmin.id,
          name: stationAdmin.name,
          stationCode: stationAdmin.stationCode!,
        },
      },
      unreadCount: {
        trainDriver: 0,
        stationAdmin: 0,
      },
      isActive: true,
      createdAt: Date.now(),
      updatedAt: Date.now(),
    };

    await set(roomRef, room);
    return roomId;
  }

  // Get chat rooms for a user
  subscribeToUserChatRooms(userId: string, userRole: 'train_driver' | 'station_admin', callback: (rooms: ChatRoom[]) => void): () => void {
    const chatsRef = ref(database, 'chats');
    
    const unsubscribe = onValue(chatsRef, (snapshot) => {
      const rooms: ChatRoom[] = [];
      if (snapshot.exists()) {
        snapshot.forEach((childSnapshot) => {
          const room = childSnapshot.val() as ChatRoom;
          
          // Check if user is participant in this room
          const isParticipant = userRole === 'train_driver' 
            ? room.participants.trainDriver.id === userId
            : room.participants.stationAdmin.id === userId;
            
          if (isParticipant && room.isActive) {
            rooms.push(room);
          }
        });
      }
      callback(rooms.sort((a, b) => b.updatedAt - a.updatedAt));
    });

    return () => off(chatsRef, 'value', unsubscribe);
  }

  // Mark messages as read
  async markMessagesAsRead(roomId: string, userRole: 'train_driver' | 'station_admin'): Promise<void> {
    const roomRef = ref(database, `chats/${roomId}`);
    await update(roomRef, {
      [`unreadCount/${userRole}`]: 0
    });
  }

  // Get unread count
  async getUnreadCount(roomId: string, userRole: 'train_driver' | 'station_admin'): Promise<number> {
    return new Promise((resolve) => {
      const roomRef = ref(database, `chats/${roomId}/unreadCount/${userRole}`);
      onValue(roomRef, (snapshot) => {
        resolve(snapshot.val() || 0);
      }, { onlyOnce: true });
    });
  }

  // Update user online status
  async updateUserStatus(userId: string, isOnline: boolean): Promise<void> {
    const userRef = ref(database, `users/${userId}`);
    await update(userRef, {
      isOnline,
      lastSeen: Date.now()
    });
  }

  // Send emergency alert
  async sendEmergencyAlert(roomId: string, senderId: string, senderName: string, senderRole: 'train_driver' | 'station_admin', alertMessage: string): Promise<void> {
    const emergencyMessage: Omit<ChatMessage, 'id' | 'timestamp'> = {
      senderId,
      senderName,
      senderRole,
      message: alertMessage,
      isRead: false,
      messageType: 'emergency',
      priority: 'emergency'
    };

    await this.sendMessage(roomId, emergencyMessage);
  }
}

export const chatService = ChatService.getInstance();
